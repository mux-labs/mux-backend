// This is your Prisma schema file,

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
  
  moduleFormat           = "cjs"
}

datasource db {
  provider = "postgresql"
}

model User {
  id               Int         @id @default(autoincrement())
  email            String      @unique
  name             String?
  sentPayments     Payment[]   @relation("SentPayments")
  receivedPayments Payment[]   @relation("ReceivedPayments")
  limits           UserLimit?
  payments         Payment[]   @relation("UserPayments") // Keep legacy for compatibility or migration
}

enum PaymentStatus {
  PENDING
  CONFIRMED
  FAILED
}

model Payment {
  id          Int           @id @default(autoincrement())
  amount      Float
  currency    String
  status      PaymentStatus @default(PENDING)
  description String?
  
  fromId      Int
  from        User          @relation("SentPayments", fields: [fromId], references: [id])
  
  toId        Int
  to          User          @relation("ReceivedPayments", fields: [toId], references: [id])
  
  userId      Int // Legacy field
  user        User          @relation("UserPayments", fields: [userId], references: [id])

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

model UserLimit {
  id                  Int     @id @default(autoincrement())
  dailyLimit          Float
  perTransactionLimit Float
  userId              Int     @unique
  user                User    @relation(fields: [userId], references: [id])
}

/// Mainnet/testnet separation for all wallets.
enum WalletNetwork {
  MAINNET
  TESTNET
}

/// User account for authentication and wallet ownership.
model User {
  id               String        @id @default(uuid())
  
  /// External authentication provider identifier (e.g., OAuth ID, wallet address)
  authId           String        @unique
  
  /// User's email address (optional)
  email            String?
  
  /// User's display name (optional)
  displayName      String?
  
  /// Account status
  status           String        @default("ACTIVE")
  
  /// Authentication provider type
  authProvider     String        @default("UNKNOWN")
  
  /// Last login timestamp
  lastLoginAt      DateTime?
  
  /// Operational metadata
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  
  /// Relation to user's wallets
  wallets          Wallet[]
  
  @@index([authId])
  @@index([authProvider])
}

/// Internal lifecycle states (wallets are not user-facing).
enum WalletStatus {
  /// Record is created but not yet usable (e.g. secret not stored or verification pending).
  PROVISIONING

  /// Wallet is usable for signing / custody operations.
  ACTIVE

  /// A rotation is in progress; a successor wallet should be created and promoted to ACTIVE.
  ROTATING

  /// Wallet is intentionally paused from use (operational hold).
  SUSPENDED

  /// Wallet is permanently disabled (no further use).
  DISABLED

  /// Wallet is suspected compromised; permanently blocked from use.
  COMPROMISED
}

/// Persistence-ready internal representation of an "invisible wallet".
model Wallet {
  id               String        @id @default(uuid())

  /// Owner reference to User model
  userId           String
  user             User          @relation(fields: [userId], references: [id])

  /// Chain-agnostic public identifier (address/public key).
  publicKey        String

  /// Chain-agnostic encrypted secret material (envelope/serialized payload).
  encryptedSecret  String

  /// Supports future crypto upgrades (KMS provider, envelope format, etc.).
  encryptionVersion Int          @default(1)

  /// Supports rotation by incrementing secret material while preserving history.
  secretVersion    Int           @default(1)

  network          WalletNetwork
  status           WalletStatus  @default(PROVISIONING)

  /// Operational metadata for audits/debugging.
  statusReason     String?
  statusChangedAt  DateTime      @default(now())

  /// Rotation history: link to the prior wallet record (if this wallet is a successor).
  rotatedFromId    String?
  rotatedFrom      Wallet?       @relation("WalletRotation", fields: [rotatedFromId], references: [id])
  rotatedTo        Wallet[]      @relation("WalletRotation")

  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  /// Recovery requests for this wallet
  recoveryRequests RecoveryRequest[]

  @@index([userId, network])
  @@index([status, network])
  @@unique([network, publicKey])
}

/// Recovery request lifecycle states
enum RecoveryStatus {
  PENDING
  IN_REVIEW
  APPROVED
  REJECTED
  COMPLETED
  CANCELLED
}

/// Recovery request entity for account recovery
model RecoveryRequest {
  id        String         @id @default(uuid())
  walletId  String
  wallet    Wallet         @relation(fields: [walletId], references: [id], onDelete: Cascade)
  requester String         // Identifier of who requested recovery (e.g., userId or email)
  status    RecoveryStatus @default(PENDING)
  metadata  Json?          // Optional metadata for future recovery methods
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  @@index([walletId, status])
}

/// API Key status lifecycle
enum ApiKeyStatus {
  ACTIVE
  REVOKED
  EXPIRED
  SUSPENDED
}

/// Developer/Project entity for SDK usage
model Developer {
  id          String   @id @default(uuid())
  email       String   @unique
  name        String?
  company     String?
  
  /// Developer status
  status      String   @default("ACTIVE")
  
  /// Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  /// Relations
  projects    Project[]
  
  @@index([email])
  @@index([status])
}

/// Project entity for organizing API keys and usage
model Project {
  id          String   @id @default(uuid())
  name        String
  description String?
  
  /// Owner reference
  developerId String
  developer   Developer @relation(fields: [developerId], references: [id], onDelete: Cascade)
  
  /// Project status
  status      String   @default("ACTIVE")
  
  /// Environment (development, staging, production)
  environment String   @default("development")
  
  /// Rate limiting configuration (requests per minute)
  rateLimitRpm Int     @default(60)
  
  /// Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  /// Relations
  apiKeys     ApiKey[]
  apiKeyUsage ApiKeyUsage[]
  
  @@index([developerId])
  @@index([status])
}

/// API Key for developer authentication
model ApiKey {
  id              String       @id @default(uuid())
  
  /// Human-readable key name/description
  name            String
  
  /// Hashed API key (never store plaintext)
  keyHash         String       @unique
  
  /// Key prefix for identification (e.g., "mux_live_" or "mux_test_")
  keyPrefix       String
  
  /// Last 4 characters of the key for identification
  lastFour        String
  
  /// Project reference
  projectId       String
  project         Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  /// Key status
  status          ApiKeyStatus @default(ACTIVE)
  
  /// Key expiration (optional)
  expiresAt       DateTime?
  
  /// Last used timestamp
  lastUsedAt      DateTime?
  
  /// Revocation info
  revokedAt       DateTime?
  revokedReason   String?
  
  /// Metadata
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  
  /// Relations
  usageRecords    ApiKeyUsage[]
  
  @@index([keyHash])
  @@index([projectId])
  @@index([status])
  @@index([keyPrefix])
}

/// API Key usage tracking for analytics and rate limiting
model ApiKeyUsage {
  id          String   @id @default(uuid())
  
  /// API Key reference
  apiKeyId    String
  apiKey      ApiKey   @relation(fields: [apiKeyId], references: [id], onDelete: Cascade)
  
  /// Project reference (denormalized for faster queries)
  projectId   String
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  /// Request details
  endpoint    String
  method      String
  statusCode  Int?
  
  /// Request metadata
  ipAddress   String?
  userAgent   String?
  
  /// Performance metrics
  responseTime Int?   // milliseconds
  
  /// Timestamp (partitioned by date for analytics)
  timestamp   DateTime @default(now())
  
  @@index([apiKeyId, timestamp])
  @@index([projectId, timestamp])
  @@index([timestamp])
}
