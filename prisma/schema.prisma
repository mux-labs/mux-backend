// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
  
  moduleFormat           = "cjs"
}

datasource db {
  provider = "postgresql"
}

model User {
  id               Int         @id @default(autoincrement())
  email            String      @unique
  name             String?
  sentPayments     Payment[]   @relation("SentPayments")
  receivedPayments Payment[]   @relation("ReceivedPayments")
  limits           UserLimit?
  payments         Payment[]   @relation("UserPayments") // Keep legacy for compatibility or migration
}

enum PaymentStatus {
  PENDING
  CONFIRMED
  FAILED
}

model Payment {
  id          Int           @id @default(autoincrement())
  amount      Float
  currency    String
  status      PaymentStatus @default(PENDING)
  description String?
  
  fromId      Int
  from        User          @relation("SentPayments", fields: [fromId], references: [id])
  
  toId        Int
  to          User          @relation("ReceivedPayments", fields: [toId], references: [id])
  
  userId      Int // Legacy field
  user        User          @relation("UserPayments", fields: [userId], references: [id])

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

model UserLimit {
  id                  Int     @id @default(autoincrement())
  dailyLimit          Float
  perTransactionLimit Float
  userId              Int     @unique
  user                User    @relation(fields: [userId], references: [id])
}

/// Mainnet/testnet separation for all wallets.
enum WalletNetwork {
  MAINNET
  TESTNET
}

/// Internal lifecycle states (wallets are not user-facing).
enum WalletStatus {
  /// Record is created but not yet usable (e.g. secret not stored or verification pending).
  PROVISIONING

  /// Wallet is usable for signing / custody operations.
  ACTIVE

  /// A rotation is in progress; a successor wallet should be created and promoted to ACTIVE.
  ROTATING

  /// Wallet is intentionally paused from use (operational hold).
  SUSPENDED

  /// Wallet is permanently disabled (no further use).
  DISABLED

  /// Wallet is suspected compromised; permanently blocked from use.
  COMPROMISED
}

/// Persistence-ready internal representation of an "invisible wallet".
model Wallet {
  id               String        @id @default(uuid())

  /// Owner reference (intentionally not a relation yet to keep this model portable).
  userId           String

  /// Chain-agnostic public identifier (address/public key).
  publicKey        String

  /// Chain-agnostic encrypted secret material (envelope/serialized payload).
  encryptedSecret  String

  /// Supports future crypto upgrades (KMS provider, envelope format, etc.).
  encryptionVersion Int          @default(1)

  /// Supports rotation by incrementing secret material while preserving history.
  secretVersion    Int           @default(1)

  network          WalletNetwork
  status           WalletStatus  @default(PROVISIONING)

  /// Operational metadata for audits/debugging.
  statusReason     String?
  statusChangedAt  DateTime      @default(now())

  /// Rotation history: link to the prior wallet record (if this wallet is a successor).
  rotatedFromId    String?
  rotatedFrom      Wallet?       @relation("WalletRotation", fields: [rotatedFromId], references: [id])
  rotatedTo        Wallet[]      @relation("WalletRotation")

  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  /// Recovery requests for this wallet
  recoveryRequests RecoveryRequest[]

  @@index([userId, network])
  @@index([status, network])
  @@unique([network, publicKey])
}

/// Recovery request lifecycle states
enum RecoveryStatus {
  PENDING
  IN_REVIEW
  APPROVED
  REJECTED
  COMPLETED
  CANCELLED
}

/// Recovery request entity for account recovery
model RecoveryRequest {
  id        String         @id @default(uuid())
  walletId  String
  wallet    Wallet         @relation(fields: [walletId], references: [id], onDelete: Cascade)
  requester String         // Identifier of who requested recovery (e.g., userId or email)
  status    RecoveryStatus @default(PENDING)
  metadata  Json?          // Optional metadata for future recovery methods
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  @@index([walletId, status])
}
