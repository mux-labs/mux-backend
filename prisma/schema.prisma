// This is your Prisma schema file,

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
  
  moduleFormat           = "cjs"
}

datasource db {
  provider = "postgresql"
}

model User {
  id               Int         @id @default(autoincrement())
  email            String      @unique
  name             String?
  sentPayments     Payment[]   @relation("SentPayments")
  receivedPayments Payment[]   @relation("ReceivedPayments")
  limits           UserLimit?
  payments         Payment[]   @relation("UserPayments") // Keep legacy for compatibility or migration
}

enum PaymentStatus {
  PENDING
  CONFIRMED
  FAILED
}

model Payment {
  id          Int           @id @default(autoincrement())
  amount      Float
  currency    String
  status      PaymentStatus @default(PENDING)
  description String?
  
  fromId      Int
  from        User          @relation("SentPayments", fields: [fromId], references: [id])
  
  toId        Int
  to          User          @relation("ReceivedPayments", fields: [toId], references: [id])
  
  userId      Int // Legacy field
  user        User          @relation("UserPayments", fields: [userId], references: [id])

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

model UserLimit {
  id                  Int     @id @default(autoincrement())
  dailyLimit          Float
  perTransactionLimit Float
  userId              Int     @unique
  user                User    @relation(fields: [userId], references: [id])
}

/// Mainnet/testnet separation for all wallets.
enum WalletNetwork {
  MAINNET
  TESTNET
}

/// User account for authentication and wallet ownership.
model User {
  id               String        @id @default(uuid())
  
  /// External authentication provider identifier (e.g., OAuth ID, wallet address)
  authId           String        @unique
  
  /// User's email address (optional)
  email            String?
  
  /// User's display name (optional)
  displayName      String?
  
  /// Account status
  status           String        @default("ACTIVE")
  
  /// Authentication provider type
  authProvider     String        @default("UNKNOWN")
  
  /// Last login timestamp
  lastLoginAt      DateTime?
  
  /// Operational metadata
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  
  /// Relation to user's wallets
  wallets          Wallet[]
  
  @@index([authId])
  @@index([authProvider])
}

/// Internal lifecycle states (wallets are not user-facing).
enum WalletStatus {
  /// Record is created but not yet usable (e.g. secret not stored or verification pending).
  PROVISIONING

  /// Wallet is usable for signing / custody operations.
  ACTIVE

  /// A rotation is in progress; a successor wallet should be created and promoted to ACTIVE.
  ROTATING

  /// Wallet is intentionally paused from use (operational hold).
  SUSPENDED

  /// Wallet is permanently disabled (no further use).
  DISABLED

  /// Wallet is suspected compromised; permanently blocked from use.
  COMPROMISED
}

/// Persistence-ready internal representation of an "invisible wallet".
model Wallet {
  id               String        @id @default(uuid())

  /// Owner reference to User model
  userId           String
  user             User          @relation(fields: [userId], references: [id])

  /// Chain-agnostic public identifier (address/public key).
  publicKey        String

  /// Chain-agnostic encrypted secret material (envelope/serialized payload).
  encryptedSecret  String

  /// Supports future crypto upgrades (KMS provider, envelope format, etc.).
  encryptionVersion Int          @default(1)

  /// Supports rotation by incrementing secret material while preserving history.
  secretVersion    Int           @default(1)

  network          WalletNetwork
  status           WalletStatus  @default(PROVISIONING)

  /// Operational metadata for audits/debugging.
  statusReason     String?
  statusChangedAt  DateTime      @default(now())

  /// Rotation history: link to the prior wallet record (if this wallet is a successor).
  rotatedFromId    String?
  rotatedFrom      Wallet?       @relation("WalletRotation", fields: [rotatedFromId], references: [id])
  rotatedTo        Wallet[]      @relation("WalletRotation")

  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  /// Recovery requests for this wallet
  recoveryRequests RecoveryRequest[]
  balances         WalletBalance[]

  @@index([userId, network])
  @@index([status, network])
  @@unique([network, publicKey])
}

/// Recovery request lifecycle states
enum RecoveryStatus {
  PENDING
  IN_REVIEW
  APPROVED
  REJECTED
  COMPLETED
  CANCELLED
}

/// Recovery request entity for account recovery
model RecoveryRequest {
  id        String         @id @default(uuid())
  walletId  String
  wallet    Wallet         @relation(fields: [walletId], references: [id], onDelete: Cascade)
  requester String         // Identifier of who requested recovery (e.g., userId or email)
  status    RecoveryStatus @default(PENDING)
  metadata  Json?          // Optional metadata for future recovery methods
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  @@index([walletId, status])
}

/// Asset types supported on Stellar
enum AssetType {
  NATIVE      // XLM
  CREDIT_ALPHANUM4   // e.g., USDC
  CREDIT_ALPHANUM12  // e.g., EURT
  LIQUIDITY_POOL_SHARES
}

/// Balance sync status for tracking indexer health
enum BalanceSyncStatus {
  SYNCED       // Balance is up-to-date with chain
  SYNCING      // Sync in progress
  STALE        // Balance hasn't been updated recently
  MISMATCH     // Detected discrepancy with on-chain state
  FAILED       // Last sync attempt failed
}

/// Indexed wallet balance for fast queries
model WalletBalance {
  id        String   @id @default(uuid())
  
  /// Wallet reference
  walletId  String
  wallet    Wallet   @relation(fields: [walletId], references: [id], onDelete: Cascade)
  
  /// Asset information
  assetType String   // AssetType enum as string
  assetCode String?  // e.g., "USDC" (null for native XLM)
  assetIssuer String? // Issuer public key (null for native XLM)
  
  /// Balance amount (stored as string to preserve precision)
  balance   String   @default("0")
  
  /// Sync metadata
  syncStatus BalanceSyncStatus @default(SYNCING)
  lastSyncedAt DateTime?
  lastSyncedLedger Int?  // Stellar ledger sequence number
  
  /// Reconciliation tracking
  lastReconciledAt DateTime?
  reconciliationAttempts Int @default(0)
  
  /// Chain state (for mismatch detection)
  onChainBalance String?  // Last known on-chain balance
  mismatchDetectedAt DateTime?
  
  /// Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([walletId, assetType, assetCode, assetIssuer])
  @@index([walletId])
  @@index([syncStatus])
  @@index([lastSyncedAt])
}

/// Balance sync job tracking for reliability
model BalanceSyncJob {
  id        String   @id @default(uuid())
  
  /// Job metadata
  jobType   String   // "FULL_SYNC", "INCREMENTAL_SYNC", "RECONCILIATION"
  status    String   // "PENDING", "RUNNING", "COMPLETED", "FAILED"
  
  /// Scope
  walletId  String?  // Null for full system sync
  network   WalletNetwork?
  
  /// Progress tracking
  walletsProcessed Int @default(0)
  walletsTotal Int?
  
  /// Results
  balancesUpdated Int @default(0)
  mismatchesFound Int @default(0)
  errorsEncountered Int @default(0)
  
  /// Timing
  startedAt DateTime?
  completedAt DateTime?
  duration Int?  // milliseconds
  
  /// Error tracking
  errorMessage String?
  errorDetails Json?
  
  /// Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([status])
  @@index([jobType])
  @@index([createdAt])
}
/// Webhook endpoint registered by developers
model WebhookEndpoint {
  id          String   @id @default(uuid())
  
  /// Project reference (links webhook to API key owner)
  projectId   String
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  /// Endpoint configuration
  url         String
  description String?
  
  /// Secret for HMAC signature verification
  secret      String
  
  /// Event types to listen for
  events      String[] // e.g., ["wallet.created", "transaction.confirmed"]
  
  /// Endpoint status
  status      String   @default("ACTIVE") // ACTIVE, DISABLED, FAILED
  
  /// Failure tracking
  consecutiveFailures Int @default(0)
  lastFailureAt DateTime?
  lastFailureReason String?
  
  /// Success tracking
  lastSuccessAt DateTime?
  
  /// Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  /// Relations
  deliveries  WebhookDelivery[]
  
  @@index([projectId])
  @@index([status])
}

/// Webhook delivery attempt tracking
model WebhookDelivery {
  id          String   @id @default(uuid())
  
  /// Endpoint reference
  endpointId  String
  endpoint    WebhookEndpoint @relation(fields: [endpointId], references: [id], onDelete: Cascade)
  
  /// Event details
  eventId     String   @unique
  eventType   String   // e.g., "wallet.created"
  payload     Json     // Event payload
  
  /// Delivery status
  status      String   // PENDING, DELIVERED, FAILED, RETRYING
  
  /// Attempt tracking
  attempts    Int      @default(0)
  maxAttempts Int      @default(5)
  
  /// Next retry time (for exponential backoff)
  nextRetryAt DateTime?
  
  /// Response details
  responseStatus Int?
  responseBody String?
  responseTime Int?   // milliseconds
  
  /// Delivery timestamps
  firstAttemptAt DateTime?
  lastAttemptAt DateTime?
  deliveredAt DateTime?
  
  /// Error tracking
  errorMessage String?
  
  /// Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([endpointId])
  @@index([status])
  @@index([nextRetryAt])
  @@index([eventType])
  @@index([createdAt])
}

/// Update the Project model to add webhook endpoints relation:
/// Add this line to the Project model:
webhookEndpoints WebhookEndpoint[]
